================================================================================
        CHAPITRE V : MISE EN OEUVRE DES SOLUTIONS ET RESULTATS
================================================================================


Introduction
------------

Apres avoir identifie les mecanismes de securite adaptes au systeme GENESIS
dans le chapitre precedent, ce chapitre presente la mise en oeuvre concrete de
ces solutions. Chaque mesure de securite est detaillee avec son implementation
technique, accompagnee de scenarios de tests et des resultats obtenus. Une
analyse critique permet d'evaluer l'efficacite des solutions deployees et
d'identifier les limites restantes.


================================================================================
V.1. Presentation des solutions de securisation proposees
================================================================================

La securisation du systeme GENESIS a ete structuree en sept axes
d'intervention, correspondant aux vulnerabilites identifiees lors de l'audit
du systeme initial :

  +----+----------------------------+-------------------------------------------+--------------------------------------------+
  | #  | Axe                        | Vulnerabilite initiale                    | Solution proposee                          |
  +----+----------------------------+-------------------------------------------+--------------------------------------------+
  | 1  | Authentification           | Mots de passe stockes en clair            | Hachage bcrypt avec migration automatique  |
  | 2  | Controle d'acces           | Pages accessibles sans connexion          | Middleware d'authentification centralise   |
  | 3  | Protection CSRF            | Formulaires sans protection               | Jetons CSRF sur tous les formulaires       |
  | 4  | Protection XSS             | Donnees affichees sans echappement        | Fonction d'echappement systematique        |
  | 5  | Injection SQL              | Requetes SQL avec concatenation directe   | Requetes preparees PDO                     |
  | 6  | Securisation des uploads   | Fichiers uploades sans validation         | Validation extension + MIME + taille       |
  | 7  | Configuration              | Identifiants disperses, headers absents   | Centralisation + headers de securite HTTP  |
  +----+----------------------------+-------------------------------------------+--------------------------------------------+


================================================================================
V.2. Mise en oeuvre pratique des mecanismes retenus
================================================================================

V.2.1. Securisation de l'authentification
-----------------------------------------

a) Hachage des mots de passe avec bcrypt

Le systeme initial stockait les mots de passe des techniciens en clair dans la
table "techniciens". La correction a consiste a implementer le hachage bcrypt
via les fonctions natives de PHP :

  - password_hash() : genere un hachage bcrypt avec sel aleatoire automatique ;
  - password_verify() : compare un mot de passe en clair avec son hachage de
    maniere securisee (resistante aux attaques par timing).

Un script de migration (migrate_passwords.php) a ete cree pour convertir les
mots de passe existants en clair vers leur version hachee, sans interruption
de service.

Un mecanisme de migration automatique a egalement ete integre dans la page de
connexion : si un utilisateur se connecte avec un ancien mot de passe en clair,
celui-ci est automatiquement remplace par sa version hachee apres verification.

  Exemple d'implementation :

    // Verification avec bcrypt
    if (password_verify($password, $row['mot_de_passe'])) {
        $login_success = true;
    } elseif ($password === $row['mot_de_passe']) {
        // Migration automatique vers bcrypt
        $hashed = password_hash($password, PASSWORD_DEFAULT);
        $updateStmt = $conn->prepare(
            "UPDATE techniciens SET mot_de_passe = ? WHERE id = ?"
        );
        $updateStmt->execute([$hashed, $row['id']]);
        $login_success = true;
    }


b) Protection contre le brute force

Un compteur de tentatives de connexion echouees a ete implemente dans le
mecanisme de login. Apres 5 tentatives infructueuses, le compte est verrouille
pendant 15 minutes. Ce mecanisme est gere par les variables de session,
indexees par l'adresse IP du client.


c) Gestion securisee des sessions

La configuration des sessions a ete renforcee avec les parametres suivants :

  +-----------+-----------+-------------------------------------------------------+
  | Parametre | Valeur    | Role                                                  |
  +-----------+-----------+-------------------------------------------------------+
  | lifetime  | 0         | Session expire a la fermeture du navigateur            |
  | httponly  | true      | Cookie inaccessible par JavaScript (anti-XSS)         |
  | samesite  | Strict    | Cookie non envoye dans les requetes cross-site (CSRF) |
  | secure    | Dynamique | Cookie transmis uniquement via HTTPS si disponible     |
  +-----------+-----------+-------------------------------------------------------+

De plus, l'identifiant de session est regenere apres chaque connexion reussie
(session_regenerate_id(true)) et periodiquement toutes les 30 minutes, afin de
prevenir les attaques par fixation de session.

Un timeout d'inactivite de 30 minutes a ete implemente : si l'utilisateur ne
fait aucune action pendant cette duree, sa session est automatiquement invalidee.

  Exemple d'implementation :

    session_set_cookie_params([
        'lifetime' => 0,
        'path'     => '/',
        'domain'   => '',
        'secure'   => isset($_SERVER['HTTPS']),
        'httponly'  => true,
        'samesite' => 'Strict'
    ]);
    session_start();


V.2.2. Mise en place du controle d'acces
-----------------------------------------

Un fichier middleware (auth_check.php) a ete cree et inclus en en-tete de
chaque page protegee du systeme. Ce middleware effectue les verifications
suivantes a chaque requete :

  1. Verification de l'existence d'une session active ;
  2. Verification du timeout d'inactivite ;
  3. Regeneration periodique de l'identifiant de session ;
  4. Application des headers de securite HTTP ;
  5. Redirection vers la page de connexion en cas d'echec.

Les pages protegees par ce mecanisme sont : le tableau de bord (index.php),
le parametrage (parametrage.php), l'historique (historique.php), l'export
Excel (excel.php), la gestion des techniciens et le controle des actionneurs.

  Exemple d'implementation :

    // Verifier si l'utilisateur est connecte
    if (!isset($_SESSION['username']) || empty($_SESSION['username'])) {
        $_SESSION['redirect_after_login'] = $_SERVER['REQUEST_URI'];
        header('Location: login.php');
        exit();
    }


V.2.3. Protection CSRF
-----------------------

Un systeme de jetons CSRF a ete implemente via trois fonctions centralisees
dans le fichier de configuration :

  - generateCSRFToken() : genere un jeton de 32 octets aleatoires
    (64 caracteres hexadecimaux) stocke en session ;
  - verifyCSRFToken() : compare le jeton soumis avec celui en session en
    utilisant hash_equals() (comparaison a temps constant, resistante aux
    attaques par timing) ;
  - csrfField() : genere le champ HTML cache a inclure dans les formulaires.

Chaque formulaire du systeme (seuils, equipements, notifications, horaires,
gestion des techniciens, fiches techniques) integre un champ cache contenant
le jeton CSRF. Le serveur verifie la validite du jeton avant tout traitement.
En cas d'echec, l'action est rejetee avec un message d'erreur.

Le jeton est regenere apres chaque soumission reussie, empechant sa
reutilisation.

  Exemple d'implementation :

    // Generation du jeton
    function generateCSRFToken() {
        if (empty($_SESSION[CSRF_TOKEN_NAME])) {
            $_SESSION[CSRF_TOKEN_NAME] = bin2hex(random_bytes(32));
        }
        return $_SESSION[CSRF_TOKEN_NAME];
    }

    // Verification du jeton
    function verifyCSRFToken($token) {
        if (empty($_SESSION[CSRF_TOKEN_NAME]) || empty($token)) {
            return false;
        }
        return hash_equals($_SESSION[CSRF_TOKEN_NAME], $token);
    }

    // Dans le formulaire HTML
    <form method="post" action="parametrage.php">
        <?php echo csrfField(); ?>
        <!-- champs du formulaire -->
    </form>


V.2.4. Protection XSS
----------------------

Une fonction d'echappement e() a ete creee, encapsulant la fonction PHP
htmlspecialchars() avec les parametres ENT_QUOTES et UTF-8. Cette fonction
est systematiquement appliquee a toute donnee affichee dans les pages HTML :

  - Valeurs des capteurs dans les tableaux et graphiques ;
  - Noms et emails des techniciens ;
  - Messages de succes et d'erreur ;
  - Parametres de configuration ;
  - Historique des modifications.

  Exemple d'implementation :

    function e($string) {
        return htmlspecialchars($string ?? '', ENT_QUOTES, 'UTF-8');
    }

    // Utilisation dans les vues
    <td><?php echo e($row['temperature']); ?></td>
    <td><?php echo e($row['date_heure']); ?></td>


V.2.5. Protection contre l'injection SQL
-----------------------------------------

Toutes les requetes SQL du systeme ont ete converties en requetes preparees
PDO. La connexion PDO est configuree avec l'option
PDO::ATTR_EMULATE_PREPARES => false, qui force l'utilisation de requetes
preparees natives cote serveur MySQL, offrant une protection maximale.

Les principales requetes securisees concernent :

  - L'insertion des donnees de capteurs (conexion_arduino.php) ;
  - La verification des identifiants de connexion (login.php) ;
  - La modification des parametres du systeme (parametrage.php) ;
  - La suppression des techniciens (delete_technicien.php) ;
  - La consultation de l'historique avec filtres (historique.php).

  Exemple d'implementation :

    // Connexion PDO securisee
    $options = [
        PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::ATTR_EMULATE_PREPARES   => false,
    ];
    $conn = new PDO($dsn, DB_USER, DB_PASS, $options);

    // Requete preparee
    $stmt = $conn->prepare(
        "INSERT INTO tabla_sensor (presion, humedad, temperatura, distancia, fecha)
         VALUES (?, ?, ?, ?, NOW())"
    );
    $stmt->bindValue(1, $pre_php, PDO::PARAM_STR);
    $stmt->bindValue(2, $hum_php, PDO::PARAM_STR);
    $stmt->bindValue(3, $temp_php, PDO::PARAM_STR);
    $stmt->bindValue(4, $dist_php, PDO::PARAM_STR);
    $stmt->execute();


V.2.6. Securisation des uploads de fichiers
--------------------------------------------

Le systeme GENESIS permet l'upload de photos de techniciens et de fiches
techniques PDF. La securisation de cette fonctionnalite repose sur une
validation en trois etapes :

  +--------+------------------+---------------------------------------------------+
  | Etape  | Verification     | Protection contre                                 |
  +--------+------------------+---------------------------------------------------+
  | 1      | Extension        | Upload de fichiers executables (.php, .exe)        |
  | 2      | Type MIME        | Fichiers dont l'extension a ete modifiee           |
  | 3      | Taille           | Deni de service par saturation du disque           |
  +--------+------------------+---------------------------------------------------+

De plus, les fichiers sont renommes avec un nom aleatoire de 32 caracteres
hexadecimaux (via random_bytes(16)), empechant la prediction des URLs et
l'execution de fichiers malveillants. Les repertoires d'upload sont crees
avec des permissions restrictives (0755 au lieu de 0777).

  Exemple d'implementation :

    function validateUpload($file, $type = 'image') {
        $errors = [];

        if ($file['error'] !== UPLOAD_ERR_OK) {
            $errors[] = "Erreur lors de l'upload.";
            return ['valid' => false, 'errors' => $errors];
        }

        if ($file['size'] > MAX_UPLOAD_SIZE) {
            $errors[] = "Fichier trop volumineux (max: 5 MB).";
        }

        if (!isAllowedExtension($file['name'], $type)) {
            $errors[] = "Extension non autorisee.";
        }

        if (!isValidMimeType($file['tmp_name'], $type)) {
            $errors[] = "Type de fichier invalide.";
        }

        return ['valid' => empty($errors), 'errors' => $errors];
    }

    function generateSecureFilename($originalName) {
        $ext = strtolower(pathinfo($originalName, PATHINFO_EXTENSION));
        return bin2hex(random_bytes(16)) . '.' . $ext;
    }


V.2.7. Configuration centralisee et headers de securite
--------------------------------------------------------

a) Fichier de configuration centralise

Un fichier config.php regroupe l'ensemble de la configuration du systeme :
identifiants de base de donnees, constantes de securite, fonctions utilitaires.
Cette centralisation elimine la duplication des identifiants dans chaque fichier
et facilite la maintenance.

  Exemple de constantes definies :

    define('DB_HOST', 'localhost');
    define('DB_NAME', 'ardbd');
    define('DB_USER', 'root');
    define('DB_PASS', '');
    define('DB_CHARSET', 'utf8mb4');

    define('CSRF_TOKEN_NAME', 'csrf_token');
    define('SESSION_TIMEOUT', 1800);       // 30 minutes
    define('MAX_LOGIN_ATTEMPTS', 5);
    define('LOGIN_LOCKOUT_TIME', 900);     // 15 minutes

    define('ARDUINO_IP', '192.168.1.150');
    define('ARDUINO_PORT', 80);
    define('ARDUINO_TIMEOUT', 5);


b) Headers de securite HTTP

Les headers suivants sont appliques a chaque reponse HTTP via la fonction
setSecurityHeaders() :

  +----------------------------+--------------------------------------+----------------------------------+
  | Header                     | Valeur                               | Protection                       |
  +----------------------------+--------------------------------------+----------------------------------+
  | X-Frame-Options            | SAMEORIGIN                           | Anti-clickjacking                |
  | X-XSS-Protection           | 1; mode=block                        | Filtre XSS du navigateur         |
  | X-Content-Type-Options     | nosniff                              | Anti-MIME sniffing               |
  | Referrer-Policy            | strict-origin-when-cross-origin      | Limite les infos de referent     |
  | Content-Security-Policy    | Politique definie                    | Restriction des sources          |
  +----------------------------+--------------------------------------+----------------------------------+

  Exemple d'implementation :

    function setSecurityHeaders() {
        header('X-Frame-Options: SAMEORIGIN');
        header('X-XSS-Protection: 1; mode=block');
        header('X-Content-Type-Options: nosniff');
        header('Referrer-Policy: strict-origin-when-cross-origin');
        header("Content-Security-Policy: default-src 'self'; ...");
    }


V.2.8. Securisation de l'endpoint Arduino
------------------------------------------

Le fichier conexion_arduino.php, qui recoit les donnees des capteurs depuis
l'Arduino, a ete securise par :

  - La validation et le filtrage de chaque parametre avec filter_var() et
    FILTER_VALIDATE_FLOAT ;
  - La verification des plages de valeurs realistes (temperature entre -50 C
    et 100 C, humidite entre 0% et 100%) ;
  - La journalisation des erreurs via error_log() pour tracer les tentatives
    d'injection ;
  - La preparation d'un mecanisme d'authentification par cle API et filtrage
    IP (configure mais commente, pret pour l'activation en production).

  Exemple d'implementation :

    $temp_php = filter_var($_GET["temp_php"] ?? null, FILTER_VALIDATE_FLOAT);
    $hum_php  = filter_var($_GET["hum_php"] ?? null, FILTER_VALIDATE_FLOAT);

    if ($temp_php === false || $hum_php === false) {
        http_response_code(400);
        echo "Erreur: Parametres invalides ou manquants";
        exit;
    }

    if ($temp_php < -50 || $temp_php > 100) {
        $errors[] = "Temperature hors limites (-50 a 100 C)";
    }
    if ($hum_php < 0 || $hum_php > 100) {
        $errors[] = "Humidite hors limites (0 a 100%)";
    }


================================================================================
V.3. Scenarios de tests de securite
================================================================================

Pour evaluer l'efficacite des mesures de securite implementees, une serie de
tests a ete realisee couvrant les principales vulnerabilites du referentiel
OWASP Top 10.


V.3.1. Test d'acces non authentifie
------------------------------------

Objectif : Verifier qu'un utilisateur non connecte ne peut pas acceder aux
pages protegees.

Procedure :
  1. Ouvrir un navigateur sans session active ;
  2. Acceder directement aux URLs protegees :
     - http://localhost/Project_final/Genesis/index.php
     - http://localhost/Project_final/Genesis/parametrage.php
     - http://localhost/Project_final/Genesis/historique.php
     - http://localhost/Project_final/Genesis/actionneur.php

Resultat attendu : Redirection automatique vers login.php.


V.3.2. Test de brute force
---------------------------

Objectif : Verifier le verrouillage du compte apres tentatives echouees.

Procedure :
  1. Acceder a la page de connexion ;
  2. Saisir un nom d'utilisateur valide ;
  3. Saisir un mot de passe incorrect 5 fois consecutives ;
  4. Tenter une 6eme connexion.

Resultat attendu : Message de blocage indiquant le temps restant (15 minutes).


V.3.3. Test d'injection SQL
----------------------------

Objectif : Verifier la resistance aux injections SQL.

Procedure :
  1. Dans le champ de connexion, saisir : admin' OR '1'='1' --
  2. Soumettre le formulaire ;
  3. Tester l'injection via l'URL de l'Arduino :
     http://localhost/.../conexion_arduino.php?temp_php=25;DROP TABLE table_capteurs--

Resultat attendu : Rejet de la requete, message d'erreur generique.


V.3.4. Test CSRF
-----------------

Objectif : Verifier la protection contre les requetes forgees.

Procedure :
  1. Se connecter normalement au systeme ;
  2. Creer une page HTML externe contenant un formulaire ciblant
     parametrage.php sans jeton CSRF ;
  3. Soumettre le formulaire depuis la page externe.

Resultat attendu : Rejet de la requete avec message "Erreur de securite".


V.3.5. Test XSS
----------------

Objectif : Verifier la resistance aux injections de scripts.

Procedure :
  1. Tenter d'inserer la chaine <script>alert('XSS')</script> dans les
     champs de saisie du parametrage ;
  2. Verifier l'affichage dans l'historique des modifications.

Resultat attendu : Le script est affiche en texte brut, non execute.


V.3.6. Test d'upload malveillant
---------------------------------

Objectif : Verifier le rejet des fichiers non autorises.

Procedure :
  1. Tenter d'uploader un fichier PHP renomme en .jpg ;
  2. Tenter d'uploader un fichier depassant 5 Mo ;
  3. Tenter d'uploader un fichier avec une double extension
     (ex. : photo.php.jpg).

Resultat attendu : Rejet du fichier avec message d'erreur approprie.


V.3.7. Test de timeout de session
----------------------------------

Objectif : Verifier l'expiration automatique de la session.

Procedure :
  1. Se connecter au systeme ;
  2. Attendre 31 minutes sans activite ;
  3. Tenter de naviguer vers une page protegee.

Resultat attendu : Redirection vers login.php avec message
"Votre session a expire".


V.3.8. Test de validation des donnees Arduino
----------------------------------------------

Objectif : Verifier le rejet des donnees hors limites.

Procedure :
  1. Envoyer une requete avec une temperature de 200 C :
     http://localhost/.../conexion_arduino.php?temp_php=200&hum_php=50
     &pre_php=1013&dist_php=30
  2. Envoyer une requete avec des parametres manquants.

Resultat attendu : Code HTTP 400, message d'erreur de validation.


================================================================================
V.4. Resultats obtenus
================================================================================

V.4.1. Tableau recapitulatif des tests
---------------------------------------

  +----+--------------------------------------------+------------------------------------------------+-----------+
  | #  | Test                                       | Resultat                                       | Statut    |
  +----+--------------------------------------------+------------------------------------------------+-----------+
  | 1  | Acces non authentifie                      | Redirection vers login.php sur toutes les pages | Reussi    |
  | 2  | Brute force (5 tentatives)                 | Compte verrouille 15 min apres 5 echecs        | Reussi    |
  | 3  | Injection SQL (login)                      | Requete rejetee, pas d'acces                   | Reussi    |
  | 4  | Injection SQL (Arduino)                    | Parametres invalides rejetes (code 400)        | Reussi    |
  | 5  | CSRF                                       | Formulaire externe rejete                      | Reussi    |
  | 6  | XSS reflechi                               | Script affiche en texte, non execute           | Reussi    |
  | 7  | Upload PHP en .jpg                         | Rejete par verification MIME                   | Reussi    |
  | 8  | Upload > 5 Mo                              | Rejete avec message d'erreur                   | Reussi    |
  | 9  | Timeout session (30 min)                   | Redirection avec message "session expiree"     | Reussi    |
  | 10 | Donnees Arduino hors limites               | Rejetees avec code 400                         | Reussi    |
  +----+--------------------------------------------+------------------------------------------------+-----------+


V.4.2. Tableau comparatif avant/apres securisation
---------------------------------------------------

  +---------------------------+--------------------------------------+----------------------------------------------+
  | Aspect de securite        | Avant securisation                   | Apres securisation                           |
  +---------------------------+--------------------------------------+----------------------------------------------+
  | Mots de passe             | Stockes en clair                     | Haches avec bcrypt                           |
  | Authentification          | Aucune verification                  | Middleware sur toutes les pages               |
  | Protection CSRF           | Absente                              | Jetons sur tous les formulaires              |
  | Protection XSS            | Vulnerable                           | Echappement htmlspecialchars() systematique   |
  | Injection SQL             | Possible (concatenation directe)     | Requetes preparees PDO                       |
  | Uploads                   | Non valides                          | Triple validation (ext. + MIME + taille)     |
  | Session                   | Non securisee                        | HttpOnly, SameSite, timeout, regeneration    |
  | Configuration             | Dispersee dans chaque fichier        | Centralisee dans config.php                  |
  | Headers HTTP              | Aucun                                | X-Frame-Options, CSP, X-Content-Type-Options |
  | Brute force               | Non protege                          | Verrouillage apres 5 tentatives (15 min)     |
  +---------------------------+--------------------------------------+----------------------------------------------+


V.4.3. Statistiques de la securisation
---------------------------------------

  +-------------------------------------------+---------+
  | Metrique                                  | Valeur  |
  +-------------------------------------------+---------+
  | Fichiers modifies                         | 14      |
  | Fichiers crees                            | 3       |
  | Vulnerabilites critiques corrigees        | 6       |
  | Vulnerabilites elevees corrigees          | 4       |
  | Total des vulnerabilites eliminees        | 10      |
  +-------------------------------------------+---------+

  Fichiers crees :
    - config.php       : Configuration centralisee et fonctions de securite
    - auth_check.php   : Middleware d'authentification
    - migrate_passwords.php : Script de migration bcrypt (usage unique)


================================================================================
V.5. Analyse et interpretation des resultats
================================================================================

V.5.1. Efficacite des mesures implementees
-------------------------------------------

Les resultats des tests demontrent que les mesures de securite implementees
couvrent efficacement les principales vulnerabilites du systeme GENESIS :

Authentification et controle d'acces :
Le passage au hachage bcrypt, combine au middleware d'authentification, elimine
les risques de vol d'identifiants et d'acces non autorise. Le mecanisme
anti-brute force ajoute une couche de protection supplementaire contre les
attaques automatisees.

Protection des formulaires :
L'implementation des jetons CSRF sur l'ensemble des formulaires du systeme
(seuils, equipements, notifications, horaires, gestion des techniciens,
actionneurs) empeche tout attaquant de forger des requetes au nom d'un
utilisateur authentifie.

Integrite des donnees :
Les requetes preparees PDO et la validation des entrees garantissent que seules
des donnees valides et correctement formatees sont inserees dans la base de
donnees. La verification des plages de valeurs pour les donnees Arduino
constitue une couche supplementaire de protection contre l'injection de
fausses donnees.

Securite de la couche de presentation :
L'echappement systematique des donnees et les headers de securite HTTP
reduisent considerablement la surface d'attaque cote client.


V.5.2. Conformite avec les standards OWASP
-------------------------------------------

Les mesures implementees adressent les vulnerabilites suivantes du referentiel
OWASP Top 10 (2021) :

  +------+------------------------------------------+---------------------------------------------------+
  | Rang | Categorie OWASP                          | Couvert par GENESIS                               |
  +------+------------------------------------------+---------------------------------------------------+
  | A01  | Controle d'acces defaillant              | Middleware auth_check, sessions securisees         |
  | A02  | Defaillances cryptographiques            | Bcrypt, recommandation HTTPS                      |
  | A03  | Injection                                | Requetes preparees PDO, validation entrees         |
  | A04  | Conception non securisee                 | Architecture defense en profondeur                 |
  | A05  | Mauvaise configuration de securite       | Configuration centralisee, headers HTTP            |
  | A07  | Cross-Site Scripting (XSS)               | Echappement systematique, CSP                      |
  | A08  | Defaillances d'integrite logicielle      | Partiellement (pas de verification CDN)            |
  | A09  | Journalisation insuffisante              | Logging des erreurs et actions                     |
  +------+------------------------------------------+---------------------------------------------------+


================================================================================
V.6. Limites de la solution mise en place
================================================================================

Malgre les ameliorations significatives apportees, la solution actuelle
presente certaines limites qu'il est important d'identifier :


V.6.1. Limites liees a la communication Arduino
-------------------------------------------------

  - Absence de chiffrement Arduino-Serveur : La communication entre l'Arduino
    et le serveur utilise toujours le protocole HTTP en clair. L'implementation
    de HTTPS ou MQTTS sur un Arduino Uno est limitee par ses contraintes de
    memoire (2 Ko de RAM). L'utilisation d'un ESP32, qui dispose de capacites
    TLS natives, pourrait resoudre cette limitation.

  - Cle API et filtrage IP non actives : Les mecanismes d'authentification de
    l'Arduino (cle API et filtrage par adresse IP) ont ete prepares dans le
    code mais sont commentes, dans l'attente de la configuration reseau
    definitive en production.


V.6.2. Limites liees a l'environnement de developpement
---------------------------------------------------------

  - Absence de HTTPS en environnement local : L'environnement de developpement
    (XAMPP sur localhost) ne dispose pas de certificat SSL/TLS. Le cookie de
    session avec l'attribut Secure ne peut donc etre active qu'en production.

  - Mot de passe de base de donnees vide : Le serveur MySQL utilise le compte
    root sans mot de passe, ce qui est acceptable en developpement mais
    inacceptable en production.

  - Stockage des identifiants dans le code source : Les identifiants de
    connexion a la base de donnees sont definis en constantes PHP. En
    production, ils devraient etre charges depuis des variables
    d'environnement.


V.6.3. Limites fonctionnelles
------------------------------

  - Absence de roles utilisateurs : Le systeme ne distingue pas differents
    niveaux de privileges (administrateur, technicien, lecteur). Tous les
    utilisateurs authentifies disposent des memes droits d'acces.

  - Absence d'authentification a deux facteurs (2FA) : Le systeme repose
    uniquement sur un couple identifiant/mot de passe. L'ajout d'un second
    facteur (code par SMS ou application TOTP) renforcerait significativement
    la securite.

  - Absence de journalisation complete : Si les erreurs sont journalisees, il
    n'existe pas de systeme d'audit complet tracant toutes les actions des
    utilisateurs (qui a consulte quoi, quand, depuis quelle IP).

  - Utilisation de unsafe-inline dans la CSP : La politique de securite du
    contenu (Content Security Policy) autorise les scripts et styles en ligne
    (unsafe-inline), ce qui reduit son efficacite contre certaines attaques
    XSS avancees.


V.6.4. Tableau recapitulatif des limites et recommandations
------------------------------------------------------------

  +------------------------------------+-------------------------------+------------------------------------------+
  | Limite                             | Impact                        | Recommandation                           |
  +------------------------------------+-------------------------------+------------------------------------------+
  | HTTP Arduino -> Serveur            | Donnees en clair sur le reseau| Migrer vers ESP32 + MQTTS ou HTTPS       |
  | Cle API Arduino inactive           | Injection de fausses donnees  | Activer en production                    |
  | Absence de HTTPS                   | Donnees utilisateur en clair  | Deployer un certificat Let's Encrypt     |
  | Identifiants dans le code          | Exposition des acces DB       | Utiliser des variables d'environnement   |
  | Pas de roles utilisateurs          | Tous les droits pour tous     | Implementer un systeme RBAC              |
  | Pas de 2FA                         | Vulnerabilite au vol de MDP   | Ajouter TOTP (Google Authenticator)      |
  | CSP avec unsafe-inline             | XSS avance possible           | Migrer vers des scripts avec nonce       |
  +------------------------------------+-------------------------------+------------------------------------------+


Conclusion du chapitre
----------------------

Ce chapitre a presente la mise en oeuvre concrete des mecanismes de
securisation du systeme GENESIS, depuis l'authentification des utilisateurs
jusqu'a la validation des donnees de capteurs. Les tests effectues confirment
l'efficacite des solutions deployees face aux attaques courantes (injection
SQL, XSS, CSRF, brute force, acces non autorise). La solution respecte les
principales recommandations du referentiel OWASP Top 10. Toutefois, des
ameliorations restent necessaires pour un deploiement en production, notamment
le chiffrement des communications Arduino, la mise en place de HTTPS et
l'implementation d'un systeme de roles utilisateurs.
